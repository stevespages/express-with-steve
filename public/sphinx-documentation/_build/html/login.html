<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Login &mdash; Learning Express 0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Learning Express 0 documentation" href="index.html" />
    <link rel="next" title="Error Handling" href="error-handling.html" />
    <link rel="prev" title="Databases" href="databases.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p><a class="reference internal" href="index.html"><em>Home</em></a></p>
<div class="section" id="login">
<h1>Login<a class="headerlink" href="#login" title="Permalink to this headline">¶</a></h1>
<div class="section" id="login-using-bcrypt">
<h2>Login Using bcrypt<a class="headerlink" href="#login-using-bcrypt" title="Permalink to this headline">¶</a></h2>
<p>Starting with an empty directory do npm init -y then npm install express sqlite3 bcrypt and then create an sqlite database called myApp.db and create a table called users in it with three fields: id, username and password.</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~/Desktop/myapp $ sqlite3 myApp.db
SQLite version 3.11.0 2016-02-15 17:29:24
Enter &quot;.help&quot; for usage hints.
sqlite&gt; CREATE TABLE users (
   ...&gt; id INTEGER PRIMARY KEY,
   ...&gt; username TEXT,
   ...&gt; password TEXT
   ...&gt; );
</pre></div>
</div>
<p>Now create an app.js file with a post route called register which will create a new user in the users table when a username and password is posted to it:</p>
<div class="code highlight-python"><div class="highlight"><pre>const express = require(&#39;express&#39;);
const bcrypt = require(&#39;bcrypt&#39;);
const sqlite3 = require(&#39;sqlite3&#39;).verbose();

const app = express()

const db = new sqlite3.Database(&#39;myApp.db&#39;);

app.use(express.json());

app.post(&#39;/register&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /register path&#39;);
    console.log(req.body.username);
    const hash = bcrypt.hashSync(req.body.password, 10);
    console.log(&#39;hash: &#39;, hash);
    let sql = `INSERT INTO users(username, password) VALUES (?, ?)`;
    db.run(sql, [req.body.username, hash], () =&gt; {});
    res.end();
});

app.listen(3000, () =&gt; {
    console.log(&#39;See localhost:3000&#39;);
</pre></div>
</div>
<p>Now when we use httpie to send a post request to localhost:3000/register we create a new row in the users table in the myApp.db database. Here is the request:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http POST localhost:3000/register username=&#39;fred&#39; password=&#39;secret&#39;
</pre></div>
</div>
<p>and here is the new row in the table:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~/Desktop/myapp $ sqlite3 myApp.db
SQLite version 3.11.0 2016-02-15 17:29:24
Enter &quot;.help&quot; for usage hints.
sqlite&gt; select * from users;
1|fred|$2b$10$sCN1XYjW/q/51QBOgwfPRuiq.fccVaNAbjUhSw0lKuHkUUszeecZG
sqlite&gt;
</pre></div>
</div>
<p>The next step is to enable a registered user to login. We will create a new post route at /login in our app.js file:</p>
<div class="code highlight-python"><div class="highlight"><pre>app.post(&#39;/login&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /login path&#39;);
    let sql = `SELECT * FROM users WHERE username = ?`;
    db.get(sql, [req.body.username], (err, row) =&gt; {
        if(!row){
            console.log(&#39;Invalid Username&#39;);
            res.end();
        } else {
            if(bcrypt.compareSync(req.body.password, row.password)){
                console.log(&#39;You are logged in&#39;);
                res.end();
            } else {
                console.log(&#39;Incorrect Password&#39;);
                res.end()
            }
        }
    })
});
</pre></div>
</div>
<p>Then httpie is used to post the correct details, followed by wrong username and finally wrong password:</p>
<div class="code highlight-python"><div class="highlight"><pre>http POST localhost:3000/login username=&#39;fred&#39; password=&#39;secret&#39;
http POST localhost:3000/login username=&#39;frediii&#39; password=&#39;secret&#39;
http POST localhost:3000/login username=&#39;fred&#39; password=&#39;wrongpassword&#39;
</pre></div>
</div>
<p>This gave the following output in the console:</p>
<div class="code highlight-python"><div class="highlight"><pre>[nodemon] restarting due to changes...
[nodemon] starting `node app.js`
See localhost:3000
You posted to the /login path
You are logged in
You posted to the /login path
Invalid Username
You posted to the /login path
Incorrect Password
</pre></div>
</div>
<p>We have now reached a point where our app is able to register new users by storing their username and hashed password in the users table of our database. We have also enabled them to login in by supplying a username and password. If there is a username in the users table corresponding to the one they login with and if the hashed password from the database is the same as the hashed password they supply at login our app is recognizes this.</p>
<p>We now need a way of enabling this logged in user to make requests to our web site without having to keep logging in for every request. This can be done by initiating a cookie based session or by JSON Web Tokens (JWT).</p>
</div>
<div class="section" id="json-web-tokens">
<h2>JSON Web Tokens<a class="headerlink" href="#json-web-tokens" title="Permalink to this headline">¶</a></h2>
<p>Now run npm install jsonwebtoken. In app.js require it and also create a secret. Modify the post.login scriptto create and return a JWT if the user logs in successfully:</p>
<div class="code highlight-python"><div class="highlight"><pre>const express = require(&#39;express&#39;);
const bcrypt = require(&#39;bcrypt&#39;);
const sqlite3 = require(&#39;sqlite3&#39;).verbose();

// NEW CODE
const jsonwebtoken = require(&#39;jsonwebtoken&#39;);

const app = express()

const db = new sqlite3.Database(&#39;myApp.db&#39;);

// NEW CODE
const SECRET = &quot;NEVER MAKE THIS PUBLIC IN PRODUCTION&quot;;

app.use(express.json());

app.post(&#39;/register&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /register path&#39;);
    console.log(req.body.username);
    const hash = bcrypt.hashSync(req.body.password, 10);
    console.log(&#39;hash: &#39;, hash);
    let sql = `INSERT INTO users(username, password) VALUES (?, ?)`;
    db.run(sql, [req.body.username, hash], () =&gt; {});
    res.end();
});

app.post(&#39;/login&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /login path&#39;);
    let sql = `SELECT * FROM users WHERE username = ?`;
    db.get(sql, [req.body.username], (err, row) =&gt; {
        if(!row){
            console.log(&#39;Invalid Username&#39;);
            res.end();
        } else {
            if(bcrypt.compareSync(req.body.password, row.password)){
                console.log(&#39;You are logged in&#39;);

                // NEW CODE
                const token = jsonwebtoken.sign(
                    { username: row.username },
                    SECRET,
                    { expiresIn: 60 * 60 }
                );
                return res.json({ token });
                // END OF NEW CODE

            } else {
                console.log(&#39;Incorrect Password&#39;);
                res.end()
            }
        }
    })
});

app.listen(3000, () =&gt; {
    console.log(&#39;See localhost:3000&#39;);
});
</pre></div>
</div>
<p>If we now make a successful login using httpie we can see a JWT is returned:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http POST localhost:3000/login username=&#39;fred&#39; password=&#39;secret&#39;
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 164
Content-Type: application/json; charset=utf-8
Date: Sun, 13 Jan 2019 23:26:08 GMT
ETag: W/&quot;a4-jxHLjTk91r3su8TlKUVWUnsFyjk&quot;
X-Powered-By: Express

{
    &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0zFX_s&quot;
}

steve@Dell ~ $
</pre></div>
</div>
<p>The browser would send this token back to the server on any future requests in its Authorization header. The server would verify the JWT and then return password protected data back to the browser. We can implement a get route in app.js to demonstrate this:</p>
<div class="code highlight-python"><div class="highlight"><pre>app.get(&#39;/secret&#39;, (req, res) =&gt; {
    const authHeaderValue = req.headers.authorization;
    const token = jsonwebtoken.verify(authHeaderValue, SECRET);
    return res.json({ message: &quot;You made it&quot; });
});
</pre></div>
</div>
<p>Now when we make a request to the /secret route with the JWT in the Authorization header, the JWT is verified and the server returns the protected data:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http get localhost:3000/secret Authorization:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0zFX_s&quot;
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 25
Content-Type: application/json; charset=utf-8
Date: Sun, 13 Jan 2019 23:57:59 GMT
ETag: W/&quot;19-pXLuIQc7MqYjz2bJcUKii/lc2L0&quot;
X-Powered-By: Express

{
    &quot;message&quot;: &quot;You made it&quot;
}
</pre></div>
</div>
<p>In the get route to /secret the code should be in a try / catch block so that if the JWT is not verified a response can be sent to the browser indicating that they are not authorized. This can be seen here:</p>
<div class="code highlight-python"><div class="highlight"><pre>app.get(&#39;/secret&#39;, (req, res) =&gt; {
    try {
        const authHeaderValue = req.headers.authorization;
        const token = jsonwebtoken.verify(authHeaderValue, SECRET);
        return res.json({ message: &quot;You made it&quot; });
    } catch(e) {
        return res.status(401).json({ message: &quot;Unauthorized&quot; });
    }
});
</pre></div>
</div>
<p>Now we send a request with the JWT followed by one in which a single character of the JWT has been changed from a z to a y:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http get localhost:3000/secret Authorization:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0zFX_s&quot;
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 25
Content-Type: application/json; charset=utf-8
Date: Mon, 14 Jan 2019 00:14:07 GMT
ETag: W/&quot;19-pXLuIQc7MqYjz2bJcUKii/lc2L0&quot;
X-Powered-By: Express

{
    &quot;message&quot;: &quot;You made it&quot;
}

steve@Dell ~ $ http get localhost:3000/secret Authorization:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0yFX_s&quot;
HTTP/1.1 401 Unauthorized
Connection: keep-alive
Content-Length: 26
Content-Type: application/json; charset=utf-8
Date: Mon, 14 Jan 2019 00:14:38 GMT
ETag: W/&quot;1a-pljHtlo127JYJR4E/RYOPb6ucbw&quot;
X-Powered-By: Express

{
    &quot;message&quot;: &quot;Unauthorized&quot;
}

steve@Dell ~ $
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Login</a><ul>
<li><a class="reference internal" href="#login-using-bcrypt">Login Using bcrypt</a></li>
<li><a class="reference internal" href="#json-web-tokens">JSON Web Tokens</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="databases.html" title="previous chapter">Databases</a></li>
      <li>Next: <a href="error-handling.html" title="next chapter">Error Handling</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/login.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Steve Greig.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/login.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>