<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Login &mdash; Learning Express 0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Learning Express 0 documentation" href="index.html" />
    <link rel="next" title="Login2" href="login2.html" />
    <link rel="prev" title="Databases" href="databases.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p><a class="reference internal" href="index.html"><em>Home</em></a></p>
<div class="section" id="login">
<h1>Login<a class="headerlink" href="#login" title="Permalink to this headline">¶</a></h1>
<div class="section" id="login-using-bcrypt">
<h2>Login Using bcrypt<a class="headerlink" href="#login-using-bcrypt" title="Permalink to this headline">¶</a></h2>
<div class="code highlight-python"><div class="highlight"><pre>npm init -y
npm install express
npm install sqlite3 bcrypt
npm install bcrypt
</pre></div>
</div>
<p>We can now create an sqlite database from the command line. Here we create a database called <cite>my-app.db</cite> and create a table called <cite>users</cite> in it with three fields: <cite>id</cite>, <cite>username</cite> and <cite>password</cite>.</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~/Desktop/myapp $ sqlite3 my-app.db
SQLite version 3.11.0 2016-02-15 17:29:24
Enter &quot;.help&quot; for usage hints.
sqlite&gt; CREATE TABLE users (
   ...&gt; id INTEGER PRIMARY KEY,
   ...&gt; username TEXT,
   ...&gt; password TEXT
   ...&gt; );
</pre></div>
</div>
<p>Now create an app.js file with a post route called register which will create a new user in the users table when a username and password is posted to it:</p>
<div class="code highlight-python"><div class="highlight"><pre>const express = require(&#39;express&#39;);
const bcrypt = require(&#39;bcrypt&#39;);
const sqlite3 = require(&#39;sqlite3&#39;).verbose();

const app = express()

const db = new sqlite3.Database(&#39;my-app.db&#39;);

app.use(express.json());

app.post(&#39;/register&#39;, function(req, res) {
    console.log(&#39;You posted to the /register path&#39;);
    console.log(req.body.username);
    const hash = bcrypt.hashSync(req.body.password, 10);
    console.log(&#39;hash: &#39;, hash);
    let sql = `INSERT INTO users(username, password) VALUES (?, ?)`;
    db.run(sql, [req.body.username, hash], () =&gt; {});
    res.end();
});

app.listen(3000, () =&gt; {
    console.log(&#39;See localhost:3000&#39;);
</pre></div>
</div>
<p>Now when we use httpie to send a post request to localhost:3000/register we create a new row in the users table in the my-app.db database. Here is the request:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http POST localhost:3000/register username=&#39;fred&#39; password=&#39;secret&#39;
</pre></div>
</div>
<p>and here is the new row in the table:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~/Desktop/myapp $ sqlite3 my-app.db
SQLite version 3.11.0 2016-02-15 17:29:24
Enter &quot;.help&quot; for usage hints.
sqlite&gt; select * from users;
1|fred|$2b$10$sCN1XYjW/q/51QBOgwfPRuiq.fccVaNAbjUhSw0lKuHkUUszeecZG
sqlite&gt;
</pre></div>
</div>
<p>The value of the password field can be broken down into four parts. After the initial $, 2b tells us bcrypt was used. After the second $ the work factor (10 in this case) is shown. After the third $ the salt is shown (about 22 characters??) followed by the hash. The work factor and salt are required by bcrypt in order to hash the password entered by the user when they login.</p>
<p>The next step is to enable a registered user to login. We will create a new post route at /login in our app.js file:</p>
<div class="code highlight-python"><div class="highlight"><pre>app.post(&#39;/login&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /login path&#39;);
    let sql = `SELECT * FROM users WHERE username = ?`;
    db.get(sql, [req.body.username], (err, row) =&gt; {
        if(!row){
            console.log(&#39;Invalid Username&#39;);
            res.end();
        } else {
            if(bcrypt.compareSync(req.body.password, row.password)){
                console.log(&#39;You are logged in&#39;);
                res.end();
            } else {
                console.log(&#39;Incorrect Password&#39;);
                res.end()
            }
        }
    })
});
</pre></div>
</div>
<p>Then httpie is used to post the correct details, followed by wrong username and finally wrong password:</p>
<div class="code highlight-python"><div class="highlight"><pre>http POST localhost:3000/login username=&#39;fred&#39; password=&#39;secret&#39;
http POST localhost:3000/login username=&#39;frediii&#39; password=&#39;secret&#39;
http POST localhost:3000/login username=&#39;fred&#39; password=&#39;wrongpassword&#39;
</pre></div>
</div>
<p>This gave the following output in the console:</p>
<div class="code highlight-python"><div class="highlight"><pre>[nodemon] restarting due to changes...
[nodemon] starting `node app.js`
See localhost:3000
You posted to the /login path
You are logged in
You posted to the /login path
Invalid Username
You posted to the /login path
Incorrect Password
</pre></div>
</div>
<p>We have now reached a point where our app is able to register new users by storing their username and hashed password in the users table of our database. We have also enabled them to login in by supplying a username and password. If there is a username in the users table corresponding to the one they login with and if the hashed password from the database is the same as the hashed password they supply at login our app recognizes this.</p>
<p>We now need a way of enabling this logged in user to make requests to our web site without having to keep logging in for every request. This can be done by initiating a cookie based session or by JSON Web Tokens (JWT).</p>
</div>
<div class="section" id="express-session">
<h2>express-session<a class="headerlink" href="#express-session" title="Permalink to this headline">¶</a></h2>
<div class="code highlight-python"><div class="highlight"><pre>npm init -y
npm install express
npm install express-session
</pre></div>
</div>
<p>To start using sessions:</p>
<div class="code highlight-python"><div class="highlight"><pre>const express = require(&#39;express&#39;);

const session = require(&#39;express-session&#39;);

const app = express()

app.use(session({
    secret: &#39;keyboard cat&#39;,
    resave: false,
    saveUninitialized: true
}));

app.get(&#39;/&#39;, function(req, res) {
    res.send(&#39;This is the home page.\n&#39;);
});

app.listen(8000);
</pre></div>
</div>
<p>Now when we send any http request to our app it will put a <cite>set-cookie</cite> header in the http response:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ curl http://localhost:8000 -v
* Rebuilt URL to: http://localhost:8000/
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; X-Powered-By: Express
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 23
&lt; ETag: W/&quot;17-+SBl1pvz95MbiP75pqzkAN/LKnY&quot;
&lt; set-cookie: connect.sid=s%3A3ETmeonNikhQIpfEopXAl4BW2eEhKklQ.BGN0%2FMwPOBEvLcPHRQI7lc%2BaR0gNDyof30WxAl%2BJphM; Path=/; HttpOnly
&lt; Date: Thu, 17 Jan 2019 18:03:59 GMT
&lt; Connection: keep-alive
&lt;
This is the home page.
* Connection #0 to host localhost left intact
steve@Dell ~ $
</pre></div>
</div>
<p>The output above shows request information prefixed with &gt; and response information prefixed with &lt;. We can see the value of the set-cookie header is <cite>connect.sid=s%3A3ET......;</cite>. This is a unique value generated by <cite>express-session</cite>.</p>
<p>When a browser receives a <cite>set-cookie</cite> header it will store it. On subsequent http requests to the same domain it will include it as a <cite>cookie</cite> header. With <cite>express-session</cite> being used in our app the app will detect the cookie in the request header and it will include the value of this cookie for its <cite>set-cookie</cite> header in its response. If the browser did not return the <cite>cookie</cite> header <cite>express-session</cite> would generate a new value and use this for its <cite>set-cookie</cite> response header.</p>
<p>We can demonstrate this behaviour using <cite>cURL</cite> to send http requests to our <cite>app.js</cite> server. First let us repeat the get request we made before. We have not instructed <cite>cURL</cite> to add a <cite>cookie</cite> header to the request so <cite>express-session</cite> will generate a new <cite>sid</cite> (session id) and use this as the value of the <cite>set-cookie</cite> header in the http response:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ curl http://localhost:8000 -v
* Rebuilt URL to: http://localhost:8000/
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; X-Powered-By: Express
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 23
&lt; ETag: W/&quot;17-+SBl1pvz95MbiP75pqzkAN/LKnY&quot;
&lt; set-cookie: connect.sid=s%3A2IYiTLnw0OqupWfXKpis7S3e4a2IfUAv.6gzGeWu3jINT1qNc1OCum40jGCMxHNnncgmmBO%2BhEa0; Path=/; HttpOnly
&lt; Date: Thu, 17 Jan 2019 22:08:20 GMT
&lt; Connection: keep-alive
&lt;
This is the home page.
* Connection #0 to host localhost left intact
steve@Dell ~ $
</pre></div>
</div>
<p>Note that the <cite>set-cookie</cite>&#8216;s connect.sid value is different from the previous response. Now let us make another get request but with the -c option followed by the name of a file (on the client side) we want cookies to be stored in:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ curl http://localhost:8000 -v -c cookie-file.txt
* Rebuilt URL to: http://localhost:8000/
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; X-Powered-By: Express
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 23
&lt; ETag: W/&quot;17-+SBl1pvz95MbiP75pqzkAN/LKnY&quot;
* Added cookie connect.sid=&quot;s%3Ar2yNnAihsLNfrEtWGAaHJpGWwvMevumZ.bhSitM%2FkVPDQ5EVA1V3tPWxApBiMZ%2FJC5FknF8%2Bjfbs&quot; for domain localhost, path /, expire 0
&lt; set-cookie: connect.sid=s%3Ar2yNnAihsLNfrEtWGAaHJpGWwvMevumZ.bhSitM%2FkVPDQ5EVA1V3tPWxApBiMZ%2FJC5FknF8%2Bjfbs; Path=/; HttpOnly
&lt; Date: Thu, 17 Jan 2019 22:13:41 GMT
&lt; Connection: keep-alive
&lt;
This is the home page.
* Connection #0 to host localhost left intact
steve@Dell ~ $
</pre></div>
</div>
<p>We can see that a file called <cite>cookie-file.txt</cite> has been created and has the cookie in it here:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ cat cookie-file.txt
# Netscape HTTP Cookie File
# http://curl.haxx.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost  FALSE   /       FALSE   0       connect.sid     s%3Ar2yNnAihsLNfrEtWGAaHJpGWwvMevumZ.bhSitM%2FkVPDQ5EVA1V3tPWxApBiMZ%2FJC5FknF8%2Bjfbs
steve@Dell ~ $
</pre></div>
</div>
<p>If we now make the same <cite>cURL</cite> request but use -b followed by the file name (instead of -c as we used before), the cookie value from the file will be sent as the value of the <cite>cookie</cite> header in the request. Our app, using <cite>express-session</cite>, will compare the value of the cookie in the header with the value of any cookies it has sent out. If the cookie in the header is the same as a cookie it has stored then the browser must have been sent the cookie from the server.</p>
<p>Once again we will send the request with the -b flag so as to include the client side stored cookie in the <cite>cookie</cite> header and we see we get exactly the same cookie back:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ curl http://localhost:8000 -v -b cookie-file.txt
* Rebuilt URL to: http://localhost:8000/
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt; Cookie: connect.sid=s%3Ar2yNnAihsLNfrEtWGAaHJpGWwvMevumZ.bhSitM%2FkVPDQ5EVA1V3tPWxApBiMZ%2FJC5FknF8%2Bjfbs
&gt;
&lt; HTTP/1.1 200 OK
&lt; X-Powered-By: Express
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 23
&lt; ETag: W/&quot;17-+SBl1pvz95MbiP75pqzkAN/LKnY&quot;
&lt; Date: Thu, 17 Jan 2019 22:48:43 GMT
&lt; Connection: keep-alive
&lt;
This is the home page.
* Connection #0 to host localhost left intact
steve@Dell ~ $
</pre></div>
</div>
<p>If a single character of the cookie is changed by editing the cookie in the cookie-file.txt file and then the request is made we get a new cookie sent back in a <cite>set-cookie</cite> response header:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ curl http://localhost:8000 -v -b cookie-file.txt
* Rebuilt URL to: http://localhost:8000/
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt; Cookie: connect.sid=s%3Ar2yNnAihsLNfrEtWGAaHJpGWwvMevumZ.bhSitM%2FkVPDQ5EVA1V3tPWxApBiMZ%2FJC5FknF8%2Bjfbt
&gt;
&lt; HTTP/1.1 200 OK
&lt; X-Powered-By: Express
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 23
&lt; ETag: W/&quot;17-+SBl1pvz95MbiP75pqzkAN/LKnY&quot;
* Replaced cookie connect.sid=&quot;s%3AgazSDLIya5bhYDxFpCi5TYaJ0rKCFcXr.%2FX85EGY5RC1oOX8ys%2BWu1BsEyu4B9OrVcb%2BjLL9%2BjoM&quot; for domain localhost, path /, expire 0
&lt; set-cookie: connect.sid=s%3AgazSDLIya5bhYDxFpCi5TYaJ0rKCFcXr.%2FX85EGY5RC1oOX8ys%2BWu1BsEyu4B9OrVcb%2BjLL9%2BjoM; Path=/; HttpOnly
&lt; Date: Thu, 17 Jan 2019 22:53:54 GMT
&lt; Connection: keep-alive
&lt;
This is the home page.
* Connection #0 to host localhost left intact
steve@Dell ~ $
</pre></div>
</div>
<p>In this case the server would have compared the incoming cookie from the browser with values in its cookie store and seen that this cookie was not in its store.  The app, through <cite>express-session</cite> will respond with a new cookie value in the <cite>set-cookie</cite> header. Although the server sent a new cookie value back to the client we did not use the -c flag in our <cite>cURL</cite> request so we did not store it and therefore the old cookie (with the single modified character we made to it) is still in the <cite>cookie-file.txt</cite> file. If this is modified back to the original value and sent as a curl request we can see from the server&#8217;s response that the server recognizes this cookie value and accepts it as valid from the fact that it does not send a <cite>set-cookie</cite> header in its response:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ curl http://localhost:8000 -v -b cookie-file.txt
* Rebuilt URL to: http://localhost:8000/
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt; Cookie: connect.sid=s%3Ar2yNnAihsLNfrEtWGAaHJpGWwvMevumZ.bhSitM%2FkVPDQ5EVA1V3tPWxApBiMZ%2FJC5FknF8%2Bjfbs
&gt;
&lt; HTTP/1.1 200 OK
&lt; X-Powered-By: Express
&lt; Content-Type: text/html; charset=utf-8
&lt; Content-Length: 23
&lt; ETag: W/&quot;17-+SBl1pvz95MbiP75pqzkAN/LKnY&quot;
&lt; Date: Thu, 17 Jan 2019 23:04:13 GMT
&lt; Connection: keep-alive
&lt;
This is the home page.
* Connection #0 to host localhost left intact
steve@Dell ~ $
</pre></div>
</div>
</div>
<div class="section" id="register-login-sessions">
<h2>Register, Login, Sessions<a class="headerlink" href="#register-login-sessions" title="Permalink to this headline">¶</a></h2>
<p>We can now bring registration, login and sessions into the same script:</p>
<div class="code highlight-python"><div class="highlight"><pre>npm init -y
npm install express
npm install express-session
npm install bcrypt
npm install sqlite3
</pre></div>
</div>
<div class="code highlight-python"><div class="highlight"><pre>const express = require(&#39;express&#39;);
const bcrypt = require(&#39;bcrypt&#39;);
const sqlite3 = require(&#39;sqlite3&#39;);
const session = require(&#39;express-session&#39;);

const app = express();

const db = new sqlite3.Database(&#39;my-app.db&#39;)

app.use(session({
    secret: &#39;process.env.SESSION_SECRET&#39;,
    resave: false,
    saveUninitialized: true
}));

// When a user logs in, the login script creates a property
// called userId on the req.session object. Any middleware or
// route handler functions can test to see if req.session.userId
// is undefined (the current user is not logged in) or defined
// (the current user is logged in). Also, the value in
// req.session.userId can still be used by any script on the site
// to obtain the identity of the logged in user.
//
// However we may want to implement a maximum period of inactivity for a user
// after which they are no longer logged in. To do this we could have a middleware
// script here which checks the value of req.session.userId. If it is undefined
// the script does nothing. If it contains a userId AND the expires date has passed
// req.session.userId is re-assigned to undefined. If req.session.userId contains a
// userId and passes all the tests such as session expiry then the script will take
// no action
//
// Pseudocode:
//
//   app.use(function(req, res, next){
//      if(req.session.userId){
//         if(req.session.expires out of date)
//            req.session.userId = undefined;
//         }
//      }
//       next();
//    });

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Is it a security risk having the user&#39;s unmodified password available in
// req.body.password after it has been used to provide the hashedPassword? Should
// it be overwritten or deleted?
app.post(&#39;/register&#39;, function(req, res, next){
    const hashedPassword = bcrypt.hashSync(req.body.password, 10);
    console.log(req.body.username);
    console.log(hashedPassword)
    let sql = `INSERT INTO users(username, password) VALUES (?, ?)`;
    db.run(sql, [req.body.username, hashedPassword], () =&gt; {});
    res.end();
});

app.post(&#39;/login&#39;, function(req, res, next){
    let sql = `SELECT * FROM users WHERE username = ?`;
    db.get(sql, [req.body.username], function(err, row){
        if(!row){
            console.log(&#39;Invalid Username&#39;);
            res.end();
        } else {
            if(bcrypt.compareSync(req.body.password, row.password)){
                req.session.userId = row.id;
                console.log(&#39;Logged in user with id: &#39;, req.session.userId);
                res.end();
            } else {
                console.log(&#39;Incorrect Password&#39;);
                res.end();
            }
        }
    });
});

app.get(&#39;/&#39;, function(req, res, next){
    if(req.session.userId){
        res.send(&#39;Hi! You are logged in. Your id = &#39; + req.session.userId);
    } else {
        res.send(&#39;Hi! You are not logged in&#39;);
    }
});

app.listen(8000);
</pre></div>
</div>
<p>A post request to /register with values for username and password will result in a new row in the users table with three fields: id (automatically generated, unique and also forming the table&#8217;s primary key), username and password. The password field will store passwords hashed with bcrypt.</p>
<p>A post request to /login with values for username and password will cause the login script to search the users table for a row where the username in the table matches the username supplied by the user in the login form. If a matching username is not found this script simply stops. A proper app would redirect back to the login form stating that their username is wrong. If a matching username is found the script then compares the bcrypt hashed password supplied by the user in the login script with the bcrypt hashed password they used when they registered. If the hashed passwords do not match our script stops but it should redirect the user to the login page stating that they have supplied an incorrect password. If the hashed passwords do match, the script assigns the id from the users table corresponding to that username to req.session.userId. Our app then stops but a real app would then redirect them to an appropriate route such as the home page.</p>
<p>When the logged in user makes a request to any page on the website (either through redirecting from the login script) or by clicking a link on the website the session cookie will be included in the http request header. In this case our app.use(session... express-session middleware will not generate a new cookie. The cookie supplied by the user&#8217;s browser will be used and the app will have access to the session object that is associated with this particular cookie and which is stored on the server. Note that the session object has data which we can put in it such as userId and this is stored on the computer not sent to the browser with the cookie. The cookie just contains the session id. Our script (including any routes) can determine that a user is logged in or not by testing that session object&#8217;s userId property (accessed by req.session.userId). That same property also tells us the identity of the user which can be used to fetch data specific to that user and return it to them in a web page. However, because we may want to consider other factors in determining whether a user is logged in or not, for example whether the session has expired, we can introduce middleware  before any routes which tests for these things. If we determine that the user should not be logged in we can simply assign req.session.user to undefined.</p>
<p>We could write a /logout route handler which reassigns req.session.userId to undefined and then redirects the user to the home page.</p>
<p>Note that several users could log into the site. Each would have a unique session id set as the value of the cookie sent to them and stored by them on their browser. On the server each of these session ids would be saved with the corresponding session object (req.session). All the users can be seen to be logged in by testing that in their invocation of our web script req.session.userId in not undefined. Each user&#8217;s identity can be established and used to provide them with tailored information from the value of req.session.userId.</p>
</div>
<div class="section" id="json-web-tokens">
<h2>JSON Web Tokens<a class="headerlink" href="#json-web-tokens" title="Permalink to this headline">¶</a></h2>
<p>Instead of using sessions to perpetuate the logged in state we can use JWTs.</p>
<div class="code highlight-python"><div class="highlight"><pre>npm install jsonwebtoken
</pre></div>
</div>
<p>In app.js require it and also create a secret. Modify the post.login script to create and return a JWT if the user logs in successfully:</p>
<div class="code highlight-python"><div class="highlight"><pre>const express = require(&#39;express&#39;);
const bcrypt = require(&#39;bcrypt&#39;);
const sqlite3 = require(&#39;sqlite3&#39;).verbose();

// NEW CODE
const jsonwebtoken = require(&#39;jsonwebtoken&#39;);

const app = express()

const db = new sqlite3.Database(&#39;myApp.db&#39;);

// NEW CODE
const SECRET = &quot;NEVER MAKE THIS PUBLIC IN PRODUCTION&quot;;

app.use(express.json());

app.post(&#39;/register&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /register path&#39;);
    console.log(req.body.username);
    const hash = bcrypt.hashSync(req.body.password, 10);
    console.log(&#39;hash: &#39;, hash);
    let sql = `INSERT INTO users(username, password) VALUES (?, ?)`;
    db.run(sql, [req.body.username, hash], () =&gt; {});
    res.end();
});

app.post(&#39;/login&#39;, (req, res) =&gt; {
    console.log(&#39;You posted to the /login path&#39;);
    let sql = `SELECT * FROM users WHERE username = ?`;
    db.get(sql, [req.body.username], (err, row) =&gt; {
        if(!row){
            console.log(&#39;Invalid Username&#39;);
            res.end();
        } else {
            if(bcrypt.compareSync(req.body.password, row.password)){
                console.log(&#39;You are logged in&#39;);

                // NEW CODE
                const token = jsonwebtoken.sign(
                    { username: row.username },
                    SECRET,
                    { expiresIn: 60 * 60 }
                );
                return res.json({ token });
                // END OF NEW CODE

            } else {
                console.log(&#39;Incorrect Password&#39;);
                res.end()
            }
        }
    })
});

app.listen(3000, () =&gt; {
    console.log(&#39;See localhost:3000&#39;);
});
</pre></div>
</div>
<p>If we now make a successful login using httpie we can see a JWT is returned:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http POST localhost:3000/login username=&#39;fred&#39; password=&#39;secret&#39;
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 164
Content-Type: application/json; charset=utf-8
Date: Sun, 13 Jan 2019 23:26:08 GMT
ETag: W/&quot;a4-jxHLjTk91r3su8TlKUVWUnsFyjk&quot;
X-Powered-By: Express

{
    &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0zFX_s&quot;
}

steve@Dell ~ $
</pre></div>
</div>
<p>The browser would send this token back to the server on any future requests in its Authorization header. The server would verify the JWT and then return password protected data back to the browser. We can implement a get route in app.js to demonstrate this:</p>
<div class="code highlight-python"><div class="highlight"><pre>app.get(&#39;/secret&#39;, (req, res) =&gt; {
    const authHeaderValue = req.headers.authorization;
    const token = jsonwebtoken.verify(authHeaderValue, SECRET);
    return res.json({ message: &quot;You made it&quot; });
});
</pre></div>
</div>
<p>Now when we make a request to the /secret route with the JWT in the Authorization header, the JWT is verified and the server returns the protected data:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http get localhost:3000/secret Authorization:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0zFX_s&quot;
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 25
Content-Type: application/json; charset=utf-8
Date: Sun, 13 Jan 2019 23:57:59 GMT
ETag: W/&quot;19-pXLuIQc7MqYjz2bJcUKii/lc2L0&quot;
X-Powered-By: Express

{
    &quot;message&quot;: &quot;You made it&quot;
}
</pre></div>
</div>
<p>In the get route to /secret the code should be in a try / catch block so that if the JWT is not verified a response can be sent to the browser indicating that they are not authorized. This can be seen here:</p>
<div class="code highlight-python"><div class="highlight"><pre>app.get(&#39;/secret&#39;, (req, res) =&gt; {
    try {
        const authHeaderValue = req.headers.authorization;
        const token = jsonwebtoken.verify(authHeaderValue, SECRET);
        return res.json({ message: &quot;You made it&quot; });
    } catch(e) {
        return res.status(401).json({ message: &quot;Unauthorized&quot; });
    }
});
</pre></div>
</div>
<p>Now we send a request with the JWT followed by one in which a single character of the JWT has been changed from a z to a y:</p>
<div class="code highlight-python"><div class="highlight"><pre>steve@Dell ~ $ http get localhost:3000/secret Authorization:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0zFX_s&quot;
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 25
Content-Type: application/json; charset=utf-8
Date: Mon, 14 Jan 2019 00:14:07 GMT
ETag: W/&quot;19-pXLuIQc7MqYjz2bJcUKii/lc2L0&quot;
X-Powered-By: Express

{
    &quot;message&quot;: &quot;You made it&quot;
}

steve@Dell ~ $ http get localhost:3000/secret Authorization:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZyZWQiLCJpYXQiOjE1NDc0MjE5NjgsImV4cCI6MTU0NzQyNTU2OH0.wbfYTs5bkvIyn7XcYvzVPAFE0JPrXnkyH2fbg0yFX_s&quot;
HTTP/1.1 401 Unauthorized
Connection: keep-alive
Content-Length: 26
Content-Type: application/json; charset=utf-8
Date: Mon, 14 Jan 2019 00:14:38 GMT
ETag: W/&quot;1a-pljHtlo127JYJR4E/RYOPb6ucbw&quot;
X-Powered-By: Express

{
    &quot;message&quot;: &quot;Unauthorized&quot;
}

steve@Dell ~ $
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Login</a><ul>
<li><a class="reference internal" href="#login-using-bcrypt">Login Using bcrypt</a></li>
<li><a class="reference internal" href="#express-session">express-session</a></li>
<li><a class="reference internal" href="#register-login-sessions">Register, Login, Sessions</a></li>
<li><a class="reference internal" href="#json-web-tokens">JSON Web Tokens</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="databases.html" title="previous chapter">Databases</a></li>
      <li>Next: <a href="login2.html" title="next chapter">Login2</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/login.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Steve Greig.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/login.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>